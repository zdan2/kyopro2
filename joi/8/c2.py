#https://atcoder.jp/contests/joi2009yo/tasks/joi2009yo_c
'''
問題
次のようなゲームがある．

あるキャラクターが縦 
1 列に 
N 個並んでいる．これらのキャラクターの色は赤，青，黄のいずれかであり，初期状態で同じ色のキャラクターが 
4 つ以上連続して並んでいることはない．プレーヤーは，ある位置のキャラクターを選び他の色に変更することができる．この操作により同じ色のキャラクターが 
4 つ以上連続して並ぶとそれらのキャラクターは消滅する．キャラクターが消滅することにより新たに同じ色のキャラクターが 
4 つ以上連続して並ぶとそれらのキャラクターも消滅し，同じ色のキャラクターが4つ以上連続して並んでいる箇所がなくなるまでこの連鎖は続く．このゲームの目的は，消滅しないで残っているキャラクター数をなるべく少なくすることである．

例えば，下図の左端の状態で，上から 
6 番目のキャラクターの色を黄色から青に変更すると，青のキャラクターが 
5 つ連続するので消滅し，最終的に 
3 つのキャラクターが消滅せずに残る．



初期状態における 
N 個のキャラクターの色の並びが与えられたとき，
1 箇所だけキャラクターの色を変更した場合の，消滅しないで残っているキャラクター数の最小値 
M を求めるプログラムを作成せよ．

入力
1 行目はキャラクター数 
N (
1≦N≦10000) だけからなる．続く 
N 行には 
1,2,3 のいずれか 
1 つの整数が書かれており，
i+1 行目 (
1≦i≦N) は初期状態における上から 
i 番目のキャラクターの色を表す（
1 は赤を，
2 は青を，
3 は黄を表す）．

出力
消滅しないで残っているキャラクター数の最小値 
M を出力せよ．
'''

n=int(input())
stack=[]
can=[]
pre=0
cur=0
for i in range(n):
    nxt=int(input())
    if pre==nxt and cur!=nxt:
        can.append((pre,i-1))
    pre=cur
    cur=nxt
    stack.append(nxt)
res=float('inf')
for color,i in can:
    s=stack.copy()
    s[i]=color
    q=[]
    c=1
    for i in range(n):
        a=s[i]
        if len(q)<3:
            q.append(a)
            continue
        if a==q[-1]:
            c+=1
            q.append(a)
        else:
            if c>3:
                for _ in range(c):
                    q.pop()
                c=1
                j=-1
                while a==q[j]:
                    c+=1
                    j-=1
                q.append(a)
            else:
                c=1
                q.append(a)
    res=min(res,len(q))
print(res)    